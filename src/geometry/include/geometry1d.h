/*!
 * \file   geometry1d.h
 * \author Robert I A Patterson
 *
 * \brief Spatial grid layout for 1d system
 *

 Copyright (C) 2009 Robert I A Patterson.

 Licence:
    This file is part of "brush".

    brush is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

  Contact:
    Prof Markus Kraft
    Dept of Chemical Engineering
    University of Cambridge
    New Museums Site
    Pembroke Street
    Cambridge
    CB2 3RA
    UK

    Email:       mk306@cam.ac.uk
    Website:     http://como.cheng.cam.ac.uk
 */
#ifndef GEOMETRY_GEOMETRY1D_H
#define GEOMETRY_GEOMETRY1D_H

#include "types.h"

#include <string>
#include <vector>

// Forward declarations

namespace CamXML {
    class Element;
}

//! Layout and boundaries of grids/meshes
namespace Geometry {

/*!
 *\brief Position information for a linear array of touching reactors
 *
 * The geometry is defined by a list of vertices (cell ends), which
 * define the cells of the spatial discretisation.  The vertices are
 * sorted by the constructors so that all cells touch their neighbours,
 * but there is no overlap.  The number of cells
 * will be one less than the number of vertices and any indices will
 * be zero based.  No default constructor is provided and one will not
 * be generated by the compiler, because another constructor is declared.
 * Default construction can never produce a valid object, because a geometry
 * must contain at least one cell.
 *
 * Terminology: "Right" refers to the direction of increasing ordinate value.
 */
class Geometry1d {
public:
    //! Read geometry from xml
    Geometry1d(const CamXML::Element &xml);

    //! Initialise object with data
    Geometry1d(const fvector& vertices,
               const BoundaryConditionType left_boundary,
               const BoundaryConditionType right_boundary);

    //! Construct a space separated string listing the cell boundaries
    std::string printMesh() const;

    //! Number of cells
    size_t numCells() const;

    //! Position of cell centre
    real cellCentre(const size_t cell_index) const;

    //! List of cell vertices
    fvector cellVertices(const size_t cell_index) const;

    //! Volume of cell
    real cellVolume(const size_t cell_index) const;

    //! Index of cell containing specified position
    int containingCell(const real x) const;

    //! Find destination of a particle being transported
    int calcDestination(const size_t origin_index, const Direction direction) const;

    //! Calculate grid spacing in specified direction
    real calcSpacing(const size_t cell_index, const Direction direction) const;

    //! Check if position is in a particular cell
    bool isInCell(const size_t cell_index, const real x) const;

private:
    //! Cells ends (should be 1 longer than array of reactors)
    fvector mCellEnds;

    //! Boundary condition at cell 0
    BoundaryConditionType mLeftBoundary;

    //! Boundary condition at final cell
    BoundaryConditionType mRightBoundary;

    //! Reactors are assumed to have a constant cross-section.
    static const real sCrossSectionalArea;
};

} //namespace Geometry

#endif // GEOMETRY_GEOMETRY1D_H

